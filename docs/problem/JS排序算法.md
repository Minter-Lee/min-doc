# JS排序算法

## 1.前言
   最近面试过程中被问及了一个问题，给定2个数组然后按大小排序，当即给出答案a.concat(b).sort()。对面小姑娘傻眼了，遂告知如果不使用这个呢？我反问有为什么不用？呃......结果可想而知，后面在跟leader的沟通中才发现他想问的是JS的一些经典排序算法，类似于插入排序，选择排序等。别说我还真不是特别清楚这些内容，或许一些算法逻辑我曾经使用过，但是这9中排序方式，复杂度等等细节我确实没法详细完整的一一说出。所以来吧，这篇文章就是用来记录这个过程的。不过我比较务实，我先要了解一下，不用sort的原因，以及这些排序所映射的应用场景，否则不就舍本求末了不是！

## 2.起源
我从JS排序算法开始检索，到后面直接检索学习算法的意义，不得不说前端这个领域里算法这方面确实比较弱，而且也让我明白了为什么大量的文章一上来就开始写××算法怎么做，而绝口不提这些内容做什么用。先来看看我摘抄的比较中肯的话

- 排序算法（Sorting algorithm）是计算机科学最古老、最基本的课题之一。要想成为合格的程序员，就必须理解和掌握各种排序算法。 ——阮一峰[《快速排序（Quicksort）的Javascript实现》](http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html "《快速排序（Quicksort）的Javascript实现》")

- 应用的话主要是商业计算，信息检索，运筹学，事件驱动模型，组合搜索这些方面——某贴吧网友

- 学习算法所锻炼出来的对各种问题敏感的反应和融会贯通能力还是非常重要的。——知乎网友

- 锻炼逻辑思维能力，明白计算机编程的核心意义。——知乎网友

- 没有一身好内功，招式再多都是空。算法是计算机科学领域最重要的基石之一，但却受到了国内一些程序员的冷落。许多学生看到一些公司在招聘时要求的编程语言五花八门就产生了一种误解， 认为学计算机就是学各种编程语言，或者认为，学习最新的语言、技术、标准就是最好的铺路方法。其实大家都被这些公司误导了。编程语言虽然该学，但是学习计算机算法和理论更重要，因为计算机语言和开发平台日新月异，但万变不离其宗的是那些算法和理论，例如数据结构、算法、编译原理、计算机体系结构、关系型数据库原理等等。在“开复学生网”上，有位同学生动地把这些基础课程比拟为“内功”，把新的语言、技术、标准比拟为“外功”。 整天赶时髦的人最后只懂得招式，没有功力，是不可能成为高手的。———李开复

如果你都看了一遍了，你会发现后面的论述已经超出排序这个话题了。是的，再次鄙视一下我的眼界，又着眼于排序这个字眼上了，而忽略了算法研究的意义，我相信大多数查阅算法文档的程序员，都不会深究背后，而仅仅是被问到了需要快速知道怎么写。我也总算是知道了为什么后端程序员总是要鄙视前端工程师，我们更多的功夫都花在招式上了（ExtJS、JQuery、Backbone、Angular、React、Vue、NodeJS...）我们所谓的基础就是用好JS的Array方法，会写一些document的操作，会写事件的监听等等。前端太上层了，似乎因为太靠外而使得编程逻辑更加具象化，对计算机语言的算法更趋于使用（如Array.sort()），而不是实现。这绝对不是好兆头！这是不是前端这个领域越来越浮躁的原因？至少目前我看是的。所以最开始我面对排序问题时的第一反应是使用Array自有的sort方法，这对于实际开发过程中没有任何问题。但是却无法获悉计算机在这方面的操作是什么，也就逐渐失去内力，泯然于众多招式中，却越学越力不从心。

我记得我曾经在大四的时候还给学弟们讲述了类似的问题，他们茫然为什么要学习工程制图，我当时的解释是空间和逻辑的锻炼，而确实也是这样，但是后来工作了，面对这么多新技术却迷失了很长一段时间。什么时候开始都不晚，我最近的学习也在不断的补充基础而不在仅仅是针对某一个技术的应用，尤其是大有理数计算这次。那就不废话了。来看看这些排序吧！

## 3.排序算法

我看很多什么必须掌握的5个算法，什么JS十大算法什么什么的。我总觉得太片面或者说噱头过重。当然不乏有些文章十分优秀。下面就开始学习成功展示。

### 3.1 标准

无论什么算法，都有优劣之分，而评判优劣的标准一定不止是时间的问题，于是关注了一些排序算法的评判准则或者说是分类也行：

- **稳定性**
    - 稳定 ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
    - 不稳定：如上条件下，a与b顺序不固定。

- **内存**
    - 内排序：所有排序操作都在内存中完成；
    - 外排序：数据过大，导致需要放入磁盘来排序，而排序通过磁盘和内存的数据传输才能进行。

- **复杂度**
    - 时间复杂度：算法执行完成所耗费的时间；
    - 空间复杂度：运行完一个程序所需内存的大小。

这里面对于复杂度我一直是较为模糊的，在选定方案的时候着重考虑时间复杂度，只有完成后，才会看看是否在空间上有过多占用，如果有问题，基本上就打乱了原有的逻辑。其实应该在选取或设计方案的时候就应考虑，是否存在耗能较大的函数或结构，尽量更贴近抽象的逻辑，这样耗能将更少。具象越多证明越靠近自然语言，而中间转化为机器语言内容更多。

OK，总之算法的好坏绝不是计算速度一条决定的，如果单论速度，何必会有那么多排序的算法？

对了，看到了许多大神推荐了一位日系程序员开发的算法可视示例，我也特别想看看，奈何怎么看都是白屏，不过先把链接发出来：[排序动画站](http://jsdo.it/norahiko/oxIy/fullscreen "排序动画站")

为了方便理解我们做如下**约定**：
**1**. var arr = [4,7,5,2]，用于各类排序举例使用；
**2**. 认定默认arr中的第一元素为有序区，后面元素为无序区。排序就是将无序区的内容有序的排列至有序区，从而形成有序数组。非必要情况下我们不定义新的数组来存储结果，而是在原数组上直接操作；
**3**. 排序是从小到大排序。

### 3.2 插入排序

我看了两个插入排序的简介，其实还是没有那么明晰，我的空间构造和存储能力确实不强，稍稍复杂一些就理不清了，这也是我数学一般般的原因。插入排序的基本思想是通过对比与有序区逐个比较大小来确定元素顺序，从而不断向有序区插入顺序确认的元素。

具体插入排序逻辑如下：

**1**. 从无序区开始迭代数组arr；
**2**. 对比当前元素arr[i]（即**无序区**第一个元素）与上一个元素arr[i-1]（即**有序区**最后一个元素也是有序区**最大**的元素）。如果比arr[i-1]大，则执行第一步。若比上一个元素小，说明当前元素至少应该排在上一个元素前，执行第三步。
**3**. 将当前元素保存为temp（名字什么都可以），准备插入使用。同时将上一个元素位置下移（即arr[i] = arr[i-1]，因为arr[i-1]一定是当前最大的，需要排在最后）
**4**. 设定j = i - 1（temp最少排在有序区的倒数第二位）， 递减j倒序循环有序区元素；
**5**. 判定temp是否小于上一位的元素arr[j-1]，若小于，将上一个元素位置向下移，j递减，继续循环，否则退出循环；
**6**.循环完毕后的j+1就是该元素的最终位置（循环体中j自动递减，所以最后位置为j+1），将该位置插入temp即可。完成后执行第一步。

上面的逻辑我是根据代码来编写的，可能不同于大多数网上的文章描述，所以你没有看到类似于重复2-5步这样的内容，都是写好了下一步要执行什么，同时为了便于理解我把每次元素都用更多的形式表述出来了，便于看时能够更好的形成空间记忆。OK话不多说，看代码：

    /**
     * [insertSort 插入排序]
     * @param {[Array]} arr 需要排序的数组
     * @return {[Array]}  arr 排序后的结果
     */
    const insertSort = (arr) => {
        let len = arr.length;
        // 1.从无序区循环
        for(let i = 1; i < len; i++) {
            // 2.与有序区最大元素比较
            if (arr[i] < arr[i-1]) {
                // 3.临时存为temp，待插入
                let temp = arr[i];
                // 4.将有序区最大为放入最后，注意此时有序区增加了一位
                arr[i] = arr[i-1];
                // 5.迭代有序区剩余元素并比较大小
                let j = i - 2;
                while( j >=0 && temp < arr[j]) {
                    // 6.若temp还小，则将arr[j]下移一位
                    arr[j+1] = arr[j];
                    // 7.j 递减 进行下次循环
                    j--;
                }
    
                //8.根据j确定最后temp位置，注入
                arr[j+1] = temp;
            }
        }   
    }

本来想在拿arr的数字来梳理一遍逻辑，但是写完代码后逻辑已经非常清楚了，我这里的代码在4、5（代码注释）处于网上的不同，主要是减免了一次循环判定。同时插入排序的元素是不需要完整替换的，仅需要一步步向下移动，最后元素会在确定后插入，而不是前后2位不断交换位置。

OK，以上就是插入排序，主要体现在最后插入上，逻辑在梳理完成后还是比较简单的。摘抄一下复杂度分析：

最佳情况：输入数组按升序排列。T(n) = O(n) 
最坏情况：输入数组按降序排列。T(n) = O(n2) 
平均情况：T(n) = O(n2)

### 3.3 二分插入排序

二分插入，很显然是对插入排序的一个优化方式，二分法说起来很简单，就是将从前到后的查找变成从中间折半，判定大小后，再折半判定，直到最终位置为止。照例，先梳理逻辑，再写代码。
**1.** 从无序区迭代arr；
**2.** 记录arr[i]为temp，设定根据有序区大小设定初始start和end；
**3.** 计算middle（start+end）获取arr[middle]为middleItem；循环判定，条件为start <= end，即start和end相邻或已经重复为止；
**4.** 判定arr[i]大于middleItem，表明arr[i]在区间内后半部分，此时start设定为middle，end不变，进行下一次循环判定；
**5.** 判定arr[i]小于middleItem，表明arr[i]在区间内前半部分，此时end设定为middle，start不变，进行下一次判定；
**6.** 判定结束后，start即为插入的位置，start之后的需要迭代向下移动一位。

未完待续



## 4.总结

我先写一小部分哈，整理插入排序的时候一直在想一个问题，这种排序算法是否能够实际应用到我们的开发中，也就是说我在找有没有不使用Array.sort()的时候。确实有，而且非常多！那就是这个排序的规则不是sort的规则的时候，也就说这个大小或者顺序的规则不是简单的数字大小（虽然sort使用的ASCII值，但其转换后还是数字），比如我就规定a,c,z,f是正序，那么这里面就像那些大于小于号，改为自己的规则即可，当然自行规则的结果需要再行封装和定义。



