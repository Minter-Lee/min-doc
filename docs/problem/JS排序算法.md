# JS排序算法

## 1.前言
   最近面试过程中被问及了一个问题，给定2个数组然后按大小排序，当即给出答案a.concat(b).sort()。对面小姑娘傻眼了，遂告知如果不使用这个呢？我反问有为什么不用？呃......结果可想而知，后面在跟leader的沟通中才发现他想问的是JS的一些经典排序算法，类似于插入排序，选择排序等。别说我还真不是特别清楚这些内容，或许一些算法逻辑我曾经使用过，但是这9中排序方式，复杂度等等细节我确实没法详细完整的一一说出。所以来吧，这篇文章就是用来记录这个过程的。不过我比较务实，我先要了解一下，不用sort的原因，以及这些排序所映射的应用场景，否则不就舍本求末了不是！

## 2.起源
我从JS排序算法开始检索，到后面直接检索学习算法的意义，不得不说前端这个领域里算法这方面确实比较弱，而且也让我明白了为什么大量的文章一上来就开始写××算法怎么做，而绝口不提这些内容做什么用。先来看看我摘抄的比较中肯的话

- 排序算法（Sorting algorithm）是计算机科学最古老、最基本的课题之一。要想成为合格的程序员，就必须理解和掌握各种排序算法。 ——阮一峰[《快速排序（Quicksort）的Javascript实现》](http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html "《快速排序（Quicksort）的Javascript实现》")

- 应用的话主要是商业计算，信息检索，运筹学，事件驱动模型，组合搜索这些方面——某贴吧网友

- 学习算法所锻炼出来的对各种问题敏感的反应和融会贯通能力还是非常重要的。——知乎网友

- 锻炼逻辑思维能力，明白计算机编程的核心意义。——知乎网友

- 没有一身好内功，招式再多都是空。算法是计算机科学领域最重要的基石之一，但却受到了国内一些程序员的冷落。许多学生看到一些公司在招聘时要求的编程语言五花八门就产生了一种误解， 认为学计算机就是学各种编程语言，或者认为，学习最新的语言、技术、标准就是最好的铺路方法。其实大家都被这些公司误导了。编程语言虽然该学，但是学习计算机算法和理论更重要，因为计算机语言和开发平台日新月异，但万变不离其宗的是那些算法和理论，例如数据结构、算法、编译原理、计算机体系结构、关系型数据库原理等等。在“开复学生网”上，有位同学生动地把这些基础课程比拟为“内功”，把新的语言、技术、标准比拟为“外功”。 整天赶时髦的人最后只懂得招式，没有功力，是不可能成为高手的。———李开复

如果你都看了一遍了，你会发现后面的论述已经超出排序这个话题了。是的，再次鄙视一下我的眼界，又着眼于排序这个字眼上了，而忽略了算法研究的意义，我相信大多数查阅算法文档的程序员，都不会深究背后，而仅仅是被问到了需要快速知道怎么写。我也总算是知道了为什么后端程序员总是要鄙视前端工程师，我们更多的功夫都花在招式上了（ExtJS、JQuery、Backbone、Angular、React、Vue、NodeJS...）我们所谓的基础就是用好JS的Array方法，会写一些document的操作，会写事件的监听等等。前端太上层了，似乎因为太靠外而使得编程逻辑更加具象化，对计算机语言的算法更趋于使用（如Array.sort()），而不是实现。这绝对不是好兆头！这是不是前端这个领域越来越浮躁的原因？至少目前我看是的。所以最开始我面对排序问题时的第一反应是使用Array自有的sort方法，这对于实际开发过程中没有任何问题。但是却无法获悉计算机在这方面的操作是什么，也就逐渐失去内力，泯然于众多招式中，却越学越力不从心。

我记得我曾经在大四的时候还给学弟们讲述了类似的问题，他们茫然为什么要学习工程制图，我当时的解释是空间和逻辑的锻炼，而确实也是这样，但是后来工作了，面对这么多新技术却迷失了很长一段时间。什么时候开始都不晚，我最近的学习也在不断的补充基础而不在仅仅是针对某一个技术的应用，尤其是大有理数计算这次。那就不废话了。来看看这些排序吧！

## 3.排序算法

我看很多什么必须掌握的5个算法，什么JS十大算法什么什么的。我总觉得太片面或者说噱头过重。当然不乏有些文章十分优秀。下面就开始学习成功展示。

### 3.1 标准

无论什么算法，都有优劣之分，而评判优劣的标准一定不止是时间的问题，于是关注了一些排序算法的评判准则或者说是分类也行：

- **稳定性**
    - 稳定 ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
    - 不稳定：如上条件下，a与b顺序不固定。

- **内存**
    - 内排序：所有排序操作都在内存中完成；
    - 外排序：数据过大，导致需要放入磁盘来排序，而排序通过磁盘和内存的数据传输才能进行。

- **复杂度**
    - 时间复杂度：算法执行完成所耗费的时间；
    - 空间复杂度：运行完一个程序所需内存的大小。

这里面对于复杂度我一直是较为模糊的，在选定方案的时候着重考虑时间复杂度，只有完成后，才会看看是否在空间上有过多占用，如果有问题，基本上就打乱了原有的逻辑。其实应该在选取或设计方案的时候就应考虑，是否存在耗能较大的函数或结构，尽量更贴近抽象的逻辑，这样耗能将更少。具象越多证明越靠近自然语言，而中间转化为机器语言内容更多。

OK，总之算法的好坏绝不是计算速度一条决定的，如果单论速度，何必会有那么多排序的算法？

对了，看到了许多大神推荐了一位日系程序员开发的算法可视示例，我也特别想看看，奈何怎么看都是白屏，不过先把链接发出来：[排序动画站](http://jsdo.it/norahiko/oxIy/fullscreen "排序动画站")

为了方便理解我们做如下**约定**：
**1**. var arr = [4,7,5,2]，用于各类排序举例使用；
**2**. 认定默认arr中的第一元素为有序区，后面元素为无序区。排序就是将无序区的内容有序的排列至有序区，从而形成有序数组。非必要情况下我们不定义新的数组来存储结果，而是在原数组上直接操作；
**3**. 排序是从小到大排序。

### 3.2 直接插入排序

我看了两个插入排序的简介，其实还是没有那么明晰，我的空间构造和存储能力确实不强，稍稍复杂一些就理不清了，这也是我数学一般般的原因。直接插入排序的基本思想是通过对比与有序区逐个比较大小来确定元素顺序，从而不断向有序区插入顺序确认的元素。

具体直接插入排序逻辑如下：

**1**. 从无序区开始迭代数组arr；
**2**. 对比当前元素arr[i]（即**无序区**第一个元素）与上一个元素arr[i-1]（即**有序区**最后一个元素也是有序区**最大**的元素）。如果比arr[i-1]大，则执行第一步。若比上一个元素小，说明当前元素至少应该排在上一个元素前，执行第三步。
**3**. 将当前元素保存为temp（名字什么都可以），准备插入使用。同时将上一个元素位置下移（即arr[i] = arr[i-1]，因为arr[i-1]一定是当前最大的，需要排在最后）
**4**. 设定j = i - 1（temp最少排在有序区的倒数第二位）， 递减j倒序循环有序区元素；
**5**. 判定temp是否小于上一位的元素arr[j-1]，若小于，将上一个元素位置向下移，j递减，继续循环，否则退出循环；
**6**.循环完毕后的j+1就是该元素的最终位置（循环体中j自动递减，所以最后位置为j+1），将该位置插入temp即可。完成后执行第一步。

上面的逻辑我是根据代码来编写的，可能不同于大多数网上的文章描述，所以你没有看到类似于重复2-5步这样的内容，都是写好了下一步要执行什么，同时为了便于理解我把每个元素都用更多的形式表述出来了，便于看时能够更好的形成空间记忆。OK话不多说，看代码：

    /**
     * [insertSort 插入排序]
     * @param {[Array]} arr 需要排序的数组
     * @return {[Array]}  arr 排序后的结果
     */
    const insertSort = (arr) => {
        let len = arr.length;
        // 1.从无序区循环
        for(let i = 1; i < len; i++) {
            // 2.与有序区最大元素比较
            if (arr[i] < arr[i-1]) {
                // 3.临时存为temp，待插入
                let temp = arr[i];
                // 4.将有序区最大为放入最后，注意此时有序区增加了一位
                arr[i] = arr[i-1];
                // 5.迭代有序区剩余元素并比较大小
                let j = i - 2;
                while( j >=0 && temp < arr[j]) {
                    // 6.若temp还小，则将arr[j]下移一位
                    arr[j+1] = arr[j];
                    // 7.j 递减 进行下次循环
                    j--;
                }
    
                //8.根据j确定最后temp位置，注入
                arr[j+1] = temp;
            }
        }   
    }

本来想在拿arr的数字来梳理一遍逻辑，但是写完代码后逻辑已经非常清楚了，我这里的代码在4、5处（代码注释）于网上的不同，主要是减免了一次循环判定。同时插入排序的元素是不需要完整替换的，仅需要一步步向下移动，最后元素会在确定后插入，而不是前后2位不断交换位置。

OK，以上就是插入排序，主要体现在最后插入上，逻辑在梳理完成后还是比较简单的。摘抄一下算法分析：

> 设待排序对象个数为n,则该算法的主程序执行n−1趟排序码比较次数和对象移动次数与对象排序码的初始排列有关。

**最好情况下**,排序前对象已经按照要求的有序。比较次数(KCN):n−1 ; 移动次数(RMN):为0。则对应的时间复杂度为O(n)。
**最坏情况下**,排序前对象为要求的顺序的反序。第i趟时第i个对象必须与前面i个对象都做排序码比较,并且每做1次比较就要做1次数据移动。比较次数(KCN):∑n−1i=1i=n(n−1)2≈n22 ; 移动次数(RMN):为∑n−1i=1i=n(n−1)2≈n22。则对应的时间复杂度为O(n2)。
如果排序记录是随机的，那么根据概率相同的原则，在平均情况下的排序码比较次数和对象移动次数约为n24，因此，直接插入排序的时间复杂度为O(n2)。

**直接插入排序算法的特点**
- 它是稳定排序，不改变相同元素原来的顺序。
- 它是in-place排序，只需要O(1)的额外内存空间。
- 它是在线排序，可以边接收数据边排序。
- 它跟我们牌扑克牌的方式相似。
- 对小数据集是有效的。

看完上面的分析我发现，我也就会写写了，还需要更深入的了解学习，考虑今后是不是需要购置一些相关书籍来系统的补充一下这方面的知识。

### 3.3 二分插入排序

二分插入，很显然是对插入排序的一个优化方式，二分法说起来很简单，就是将从前到后的查找变成从中间折半，判定大小后，再折半判定，直到仅剩一位为止。照例，先梳理逻辑，再写代码。
**1.** 从无序区迭代arr；
**2.** 记录arr[i]为temp，设定根据有序区大小设定初始start和end；
**3.** 计算middle（start+end）获取arr[middle]为middleItem；循环判定，条件为start <= end，即start和end相邻或已经重复为止；
**4.** 判定arr[i]大于middleItem，表明arr[i]在区间内后半部分，此时start设定为middle，end不变，进行下一次循环判定；
**5.** 判定arr[i]小于middleItem，表明arr[i]在区间内前半部分，此时end设定为middle，start不变，进行下一次判定；
**6.** 判定结束后，start即为插入的位置，start之后的需要迭代向下移动一位。

    /**
     * [binaryInsertSort 二分插入排序]
     * @param {[Array]} arr 需要排序的数组
     * @return {[Array]}  arr 排序后的结果
     */
    const binaryInsertSort = (arr) => {
        let len = arr.length;
    
        // 1.从无序区开始迭代
        for(let i = 1; i < len; i++) {
            let start = 0,
                end = i - 1,
                temp = arr[i];
            // 2.判定start与end是否重叠
            while(start <= end) {
                // 3. 计算中间值，注意此处仅取整
                let middle = parseInt(( start + end ) / 2);
                // 4.当前值在后半部分，调整start
                if(temp > arr[middle]){
                    start = middle + 1;
                }
                // 5.当前值在前半部分，调整end
                else {
                    end = middle - 1;
                }
            }
    
            // 6.start与end重叠后，将有序区中start之后（包含start）的元素顺移一位
            for(let j = i -1; j >= start; j--) {
                arr[j + 1] = arr[j];
            }
    
            // 7.在start处插入当前元素，完成该元素的排序
            arr[start] = temp;
        }
    }

本来写到这里，二分插入排序就应该完成了，但是我在研究的过程中有大量的手稿内容并没有体现在文档中，这是宝贵的思考过程，简单一点儿的就不写了，复杂一点儿或者我有些其他想法的不如来写写，拓展一下思路。理清排序过程不失为一个好方式，就拿我们前面定义的arr来梳理一遍排序过程，为了方便理解我将代码注释中加入了序号，思路中的序号将与此对应。

从第1步开始（即注释1位置，后面表明是注释的步骤）即**i = 1**：
- **=>** start初始为0，end为0，temp为7，执行2；
- **=>** start==end，进入循环，执行3；
- **=>** middle为0，arr[middle] = 4，执行4；位置如图：
![](https://i.imgur.com/fgb7WRD.png)
- **=>**7 > 4，start = middle + 1，start为1，end为0，跳出循环，执行6；位置如图：
![](https://i.imgur.com/p8DuOCG.png)
- **=>** j = 0，j < start，不符合循环条件，执行7；
- **=>** arr[start] = temp，即arr[1] = 7；此时数组为 [4,7,5,2]；有序区变为[4,7]无序区变为[5,2]，完成第一次循环i累加，进入第二次循环；
![](https://i.imgur.com/RHUOqCP.png)

**i = 2**：
- **=>** start为0，end为1，temp为5，执行2；
- **=>** start<end，进入循环，执行3；
- **=>** middle为0，arr[middle] = 4，执行4；如图：
![](https://i.imgur.com/nY8NycR.png)
- **=>** 5 > 4，start = middle + 1，start为1，end为1，继续循环，执行3；
- **=>** middle为1，arr[middle] = 7，执行5；如图：
![](https://i.imgur.com/BEWJpup.png)
- **=>** 5 < 7，end = middle - 1，end为0，start为1，跳出循环，执行6，位置如图：
![](https://i.imgur.com/wRfZZDk.png)

- **=>** j = 1，j = start，符合循环条件，将arr[1]向后移一位，跳出循环，执行7，此时数组为：
![](https://i.imgur.com/2GqPJq4.png)
- **=>** arr[start] = temp，即arr[2] = 5，此时数组为 [4,5,7,2]；有序区变为[4,5,,7]，无序区变为[2]，i累加，进入第三次循环；
![](https://i.imgur.com/Dy6qhcJ.png)

**i = 3**：
- **=>** start为0，end为2，temp为2，执行2；
- **=>** start<end，进入循环，执行3；
- **=>** middle为1，arr[middle] = 5，执行5；如图：
![](https://i.imgur.com/K9rSB5c.png)
- **=>** 2 < 5，end = middle - 1，start为0，end为0，继续循环，执行3；
- **=>** middle为0，arr[middle] = 4，执行5；如图：
![](https://i.imgur.com/tqNJOKK.png)
- **=>** 2 < 4，end = middle - 1，end为-1，start为0，跳出循环，执行6，位置如图：
![](https://i.imgur.com/YhF1mgh.png)
- **=>** j = 2，j > start，符合循环条件，将arr[2]，arr[1]，arr[0]依此向后移一位，跳出循环，执行7，此时数组为：
![](https://i.imgur.com/jCSHBGC.png)
- **=>** 执行arr[start] = temp，即arr[0] = 2，此时数组为 [2,4,5,7]；有序区变为[2,4,5,7]，无序区变为[]，i累加，超出边界跳出循环，完成排序；
![](https://i.imgur.com/Xm2iMsP.png)

这个小例子虽然小，但基本上覆盖了所有排序判定的分支，这种细致的罗列之后，你会发现，插入二字的由来。对于位置确定的判定上，我最开始想着start与end重合的位置就是插入的位置，但是从i=1的时候你就会发现，重合后根据与元素的对比有可能start还会改变，所以针对此处我最开始的设想是错误的，也就没法判定去优化这部分。OK，摘抄一下算法分析：

- 二分搜索比顺序搜索查找快,所以二分插入排序就平均性能来说比直接插入排序要快。
- 它所需的排序码比较次数与待排序对象序列的初始排列无关,仅依赖于对象个数。在插入第i个对象时,需要经过log2i+1次排序码比较,才能确定它应插入的位置。 将n个对象用折半插入排序所进行的排序码比较次数比较次数(KCN)：∑n−1(log2i+1)≈nlog2n
- 二分插入排序是一个稳定的排序方法。
- 当n较大时,总排序码比较次数比直接插入排序的最坏情况要好得多,但比其最好情况要差。
- 在对象的初始排列已经按排序码排好序或接近有序时,直接插入排序比折半插入排序执行的排序码比较次数要少。折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列。

## 3.4 希尔排序

希尔排序是插入排序的一种，或者更贴切的说它是插入排序的一个前置优化器，我们知道直接插入排序最好的情况下复杂度是O(n)。即数组是有序的，那如果将数组逐步变成基本有序的，就会极大增加直接插入排序的效能。什么叫基本有序呢？就是小的基本在前部分，大的基本靠后，不大不小的基本在中间。如果实现有序的排序，那么插入排序的复杂度将彻底低于O(n<sup>2</sup>)。希尔排序做到了，它开创了冲破O(n<sup>2</sup>)复杂度的先河。

那希尔排序是什么呢？希尔排序也称为缩小增量排序。希尔是为了纪念希尔这个人才加的前缀，缩小增量才是他的方法。大致逻辑如下，我们将数组元素分为若干组，这个若干一般采用length/2取整，可以称之为步长gap，是希尔建议的，但不是最优的，最优解是个数学难题，我们就不深入讨论了。这个组不是相邻元素构成，而是从起始位置累加gap所得。之后再组内排序，交换位置。再计算gap=gap/2在分组排序，直到gap为1，即分为一组，此时数组元素就基本有序，我们再调用直接插入排序即可。来看图示：
![](https://i.imgur.com/ES0wMKg.png)

清晰不，我建议学习的时候都按照自己的思路画一遍过程，这样逻辑会非常清楚，我看了所有专业，非专业的希尔排序的介绍，都不如一张图来的易懂。写代码的时候稍稍有点儿卡住了，逻辑不复杂但是转化为机器语言就恶心了。主要是组内排序用插入排序，然后需要记录好下标在插入回原位置。

    /**
     * [shellSort 希尔插入排序]
     * @param {[Array]} arr 需要排序的数组
     * @return {[Array]}  arr 排序后的结果
     */
    const shellSort = (arr) => {
        let len = arr.length,
            gap = parseInt(len / 2);
    
        for(let i = 0; i < gap; i++) {
            let tempArr = [arr[i]];
            let g = gap;
            while (g <= len){
                tempArr.push(arr[g]);
                g += gap;
            }
            let sArr = insertSort(tempArr);
            let j = sArr.length-1;
            while(g > i) {
                g = g-gap;
                arr[g] = sArr[j];
                j--;
            }
    
            return insertSort(arr);
            
        }
    }

这是第一版代码，基本思路是正确的，但是明显还有优化的地方，明天接着来，未完待续






## 4.总结

我先写一小部分哈，整理插入排序的时候一直在想一个问题，这种排序算法是否能够实际应用到我们的开发中，也就是说我在找有没有不使用Array.sort()的时候。确实有，而且非常多！那就是这个排序的规则不是sort的规则的时候，也就说这个大小或者顺序的规则不是简单的数字大小（虽然sort使用的ASCII值，但其转换后还是数字），比如我就规定a,c,z,f是正序，那么这里面就像那些大于小于号，改为自己的规则即可，当然自行规则的结果需要再行封装和定义。

今天本以为可以写完好几个排序方法，但是越写越嫌不细致，感觉虚，所以仔仔细细的跟了一遍排序的过程，并且用一个简单数组按照逻辑走了一遍，自己画了一边图，顿时感觉非常清晰，对原来模糊的位置也明确了。好方法谨记，就是时间花的多点儿。


