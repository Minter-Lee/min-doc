# 大有理数计算

## 1. 前言

惯例，先来絮叨絮叨琐事。近几日在迷茫于工作问题中，是的，几近两个月了还没有找到合适的工作，原因诸多，反正就是没接到满意的offer然后去上班，心态从兴奋到焦虑到麻木。或者说我冷静下来了吧。最近写了个磁场的小CSS动画，好玩儿之余也觉得貌似不想去开什么话题来写文档了，正巧昨天第三个阿里系职位在线笔试。第一题是大数相加。当时看到就是一脸懵逼，先做了其他两题后才有了些思路，后面电话聊这些的时候顺带又被问了减法、乘法和除法。让我觉得有必要去好好写写这道应用题的思考过程和解决方案背后的逻辑。真的是引人深思。也是我第一次深刻认识事物本质与语言的关系。

这标题我改了，原来叫大有理数计算，写道后面总提小数的问题，不如就一并来了吧，查了半天，才知道包含有理数包含分数和整数。

## 2.JS数字

首先，JS是弱类型语言，但是还是有一些基本类型和引用类型。关于数字方面就是Number。并没有细分整数，浮点数。它通过IEEE754来表示这两者。这里有个经典的问题，0.1+ 0.2 =？因为使用IEEE754浮点计算在舍入方面存在BUG，0.1+0.2=0.30000000000000004，不用去数零了，浮点数精度是17位小数。但是奇葩的时候0.15+0.15是恒等于0.3的，具体IEEE754因为什么而产生的这个问题，我没有去深入研究，本篇文章暂时不去讨论。

我们都知道Java的数值类型都有自己的边界值，JS同理，直接调用Number.MAX_VALUE，即可获得Number的最大值1.7976931348623157e+308。Number.MIN_VALUE为5e-324。这两个边界值应该算是非常大了，当然还需要考虑正负问题，也就是Number独有的两个值Infinity（正无穷）和-Infinity（负无穷）。

OK，对于NaN和各类数值转换的问题就不继续深入了。我们来谈谈，超出边界值后，如何计算的问题。这里面我先抛开小数问题，因为就加减乘除来说除了小数点外，其余逻辑是一致的，所以这里先来说说大整数计算。

## 3.大整数计算

为了方便书写和理解我们先做如下约定：

- 大整数缩写为bigNum
- 假设 bigNum1 = ‘12387315697367234’,bigNum2 = '2763712979323' 这两个数超出边界了 

### 3.1 加法

我先说一句话，不要把简单问题复杂化。大整数加法也是加法，逃脱不了数学计算的本质，我们只不过变相去实现越界数值的计算而已，请你回忆一下小学时老师是怎么教授加法计算的。尤其是两位数相加的时候，个位加个位，十位加十位，逐位相加，还有进位的问题，在下一位相加是也要加入。OK就按照这个思路来。我们拆解大整数然后逐位求和，考虑好进位问题，就能完全解决大整数的相加问题。那么关键问题是拆解和逐位这两个点。

-  **1. 拆解**

先来观察一下bigNum1，哎？是个字符串，为啥呢？越界了，数字已经无法表示了。所以用字符串的时候保留数字。再来看JS中结构化数据，操作数据最灵活的类型是啥？Array！将bigNum转换成数组后我们就可以完成了初步的拆解工作。但是别忘了，我们加减法的时候是从个位开始计算的，要不要将数据反转一下？NO，Array提供了前入、前出、后入、后出，四个方法，这里面完全可以灵活的获取最后一位来开始计算。代码很简单：

    var bigNum1Array = bigNum1.split(''),
        bigNum2Array = bigNum2.split('');

-  **2. 逐位求和**

既然要逐位，肯定要将Array循环迭代，for循环是常用手段，那么中间的循环次数条件我们选择谁呢？两个大整数的位数不一定相等，我们应该选择更长的那个作为循环次数限定，那就还各取length比较一下在作为条件？那如果最后一次相加还存在进位呢？我们是不是还要再循环一次才能完成这个计算过程？不如选择while，满足条件就循环，不必精确次数。这样多条件的情况下逻辑更清晰，结构也更简单。这也是为什么会有那么多迭代器的原因，我们不能傻傻的回一个就行了。代码如下：

    var c = 0, // 标识每次进位数，默认是0
        result = []; // 结果存储
    
    while(bigNum1Array.length || bigNum2Array.length || c) {
        // doSomething...
    }

接下来就是要doSomething了，我将步骤写入代码中，方便理解。（PS：对于复杂逻辑来讲，当你思路不太清晰时，不同先写好步骤注释，然后按照注释一一写入代码，当然过程中也可以与注释相互印证，不断理清思路）

    // 1. 分别获取数据末位
    var a = parseInt(bigNum1Array.pop()) || 0,
        b = parseInt(bigNum2Array.pop()) || 0;
    // 2. 相加求和，再加入进位数c
    var r = a + b + c;
    // 3. 判定和大小，大于9时，根据结果除10来获取整数和余数
    if( r > 9 ) {
        // 整数即下一次计算的进位数整数即下一次计算的进位数
        c = Math.floor(r/10);
        // 余数为本位加法结果数
        r = r%10;
    }else {
        // 4. 进位数归零
        c = 0;
    }
    // 5. 从前注入结果集
    result.unShift(r);

根据注释思路写完代码后，我们在逻辑没有问题的情况下，可以精简一部分代码，以微小的可读性为代价，让代码不显得那么臃肿。这个度由你来把控，不过请注意，就算是以后这代码只会有你一个人看，也不要用太多奇技淫巧，你会忘的，这是事实和真理，不要太傲娇。何况，谁能这么保证呢？团队协作，分享知识的时候，永远不是以你看得懂不懂为基准，而是大部分人是否能够较为舒服和快速的理解为准，注意，舒服且快速是很重要的。当然，你还需要权衡稳定和性能两方面，但是基本方向是不会变的，代码不是你的，是大家的。能让别人看懂是第一要素。OK，回归我们的代码，我将组合一些描述，精简一些代码。使之更美观而不会降低太多可阅读性。

    // 1. 分别获取数据末位，相加求和，再加入进位数c
    var r = (parseInt(bigNum1Array.pop()) || 0) + ( parseInt(bigNum2Array.pop()) || 0) + parseInt(c);
    // 2. 判定和大小，大于9时，根据结果除10来获取整数和余数
    if( r > 9 ) {
        // 因为是除10，所以表明，r的十分位即是除十取整结果，个位即为取余结果
        var rArray = r.toString().split('');
        c = rArray[0];
        r = rArray[1];
    }else {
        // 4. 进位数归零
        c = 0;
    }
    // 5. 从前注入结果集
    result.unShift(r);

OK，关于加法，我们的第一完整版本如下：

    function bigNumPlus(bigNum1,bigNum2) {
        var bigNum1Array = bigNum1.split(''),
        bigNum2Array = bigNum2.split(''),
        c = 0, // 标识每次进位数，默认是0
        result = []; // 结果存储
        
        // 由于bigNumArray在不断递减，所以length每次都需要重新获取
        while(bigNum1Array.length || bigNum2Array.length || c) {
            // 1. 分别获取数据末位，相加求和，再加入进位数c
            var r = (parseInt(bigNum1Array.pop()) || 0) + ( parseInt(bigNum2Array.pop()) || 0) + parseInt(c);
            // 2. 判定和大小，大于9时，根据结果除10来获取整数和余数
            if( r > 9 ) {
                // 因为是除10，所以表明，r的十分位即是除十取整结果，个位即为取余结果
                var rArray = r.toString().split('');
                c = rArray[0];
                r = rArray[1];
            }else {
                // 4. 若小于9，进位数归零
                c = 0;
            }
            // 5. 从前注入结果集
            result.unshift(r);
        }

        return result.join('');
    }

### 3.2 减法

从加法来看，减法的要点在于哪里，在于相减为负时，需要借位，也就是下一位相减时，需要多减一个借位数。这里，借位数由判定差大于0的次数决定，即加了几次10来确定。当前位的差有最后计算大于0的差决定。我们直接看代码：

    function bigNumSub(bigNum1,bigNum2) {
        var bigNum1Array = bigNum1.split(''),
        bigNum2Array = bigNum2.split(''),
        b = 0, // 标识每次借位数，默认是0
        result = []; // 结果存储
        
        // 由于bigNumArray在不断递减，所以length每次都需要重新获取
        while(bigNum1Array.length || bigNum2Array.length || b) {
            // 1. 分别获取数据末位，相减求差，再减入进位数b
            var r = (parseInt(bigNum1Array.pop()) || 0) - ( parseInt(bigNum2Array.pop()) || 0) - parseInt(b);
            // 2. 判定差大小，累加借位数，重新计算该位差，直到>0
            while( r < 0 ) {
                b++;
                r = parseInt(r)+parseInt(10*b); 
            }

            // 从前注入结果集
            result.unshift(r);
        }

        return result.join('');
    }

通过对比加法发现，我们似乎仅是借位数和差的计算逻辑稍有变动，其余都一致。但是，减法就这么简单？我们什么时候学习的负数？两个正数相减的结果可以是负数，负数的算法可不是借位法。例如15-20，我们计算的实际逻辑为-(20-15)。后半部分符合借位法规则，前半部分我们要加入负号。

回到大整数的减法逻辑中，既然有两种分支逻辑，我们如何区分，换言之如何两个bigNum谁大谁小，单纯比较length并不能完全覆盖结果。正整数相减为负数的算式中，有一个特性，那就是减至最后一位时，还需要借位，也就是说我们在相减结束后再去判定是否还存在借位数，即可得出bigNum大小的问题。那这里就不用去比较length了吗？从逻辑上讲是前者完美覆盖后者，确实可以简化，但是前者的判定需要循环至最后一次才能得出结论，也就是说怎样都要先完成借位法逻辑，才能知道使用是否适合。这代价太高，不如加入length的比较，规避一些性能损耗，调优代码效率。
再者，我们需要对原有的借位法逻辑进行封装管理，因为，负数计算的主要逻辑还是这部分，整合代码如下：
    
    // 私有标准借位法求差，并返回最后借位数
    function _bigNumSub(bigNum1, bigNum2) {
        var bigNum1Array = bigNum1.split(''),
            bigNum2Array = bigNum2.split(''),
            b = 0, // 标识每次借位数，默认是0
            result = [];
    
        // 由于bigNumArray在不断递减，所以length每次都需要重新获取 
        while(bigNum1Array.length || bigNum2Array.length) {
            // 分别获取数据末位，相减求差，再减入进位数b
            var r = ( parseInt(bigNum1Array.pop()) || 0 ) 
                    - ( parseInt(bigNum2Array.pop()) || 0 ) 
                    - parseInt(b);

            // 归零本位借位数
            b = 0;
            
            // 判定差大小，累加借位数，重新计算该位差，直到>0
            while( r < 0 ) {
                b++;
                r = parseInt(r)+parseInt(10*b); 
            }

            // 从前注入结果集
            result.unshift(r);
        }

        // 删除由于位数差异产生的多余的0
        while(result[0] === 0){
            result.shif()
        }        

        return {
            result: result,
            b: b
        }
    }
    
    // 私有大整数减法负数处理
    function _bigNumSubMinus(bigNum1,bigNum2) {
        var result =  _bigNumSub(bigNum2, bigNum1).result;
        result.unshift('-');
        return result;
    }
    
    // 公有API减法
    function bigNumSub(bigNum1,bigNum2) {
        var result = [];
        
        // 判定长短，确认大小
        if(bigNum1.length >= bigNum2.length) {
            var re =  _bigNumSub(bigNum1, bigNum2);
            result = re.result;
            
            // 若还存在借位数，调换被减数和减数
            if (re.b > 0 ){
                result = _bigNumSubMinus(bigNum2, bigNum1);
            }
        } else  {
            // 绝对长度小于减数，调换被减数位置
            result = _bigNumSubMinus(bigNum2, bigNum1);
        }
        
        return result.join('');
    }

绝不要相信自己每一次写代码都会没有问题，百密还有一疏。就上面那段代码我写的比较完整后还有三个问题，这里写出来是为了告诉读者，每段代码都应该有思考，有认识，而不是仅仅实现功能就好：
- 上段代码中，由于使用的是array.pop()方法来从末位获取数字，所以第一次借位法后，传入的数组已经为空了，不得已将数传入_bigNumSub中去转化数组。
- unshift的返回值是新数组的长度，需要单独书写一下。
- 我踌躇了一会儿，对于出现负数的情况有两种，代码中也有两处地方进行同样的处理，虽然内容很少，看着还是很别扭，试着修正了一下逻辑，感觉不是很通畅，遂提取出来为_bightSubMinus，但是代码耦合度很高。后续写完小数、乘法、除法后再行看看能不能处理的更好。

OK，针对大整数的加法和减法基本上就没有什么问题了，如果你说还有负有理数参与的加减法，我觉可以在正式计算前，判定两个大整数是否有负号，根据负号情况和具体算法（＋－×÷）来确定调用的真正方法如（负数相减转化为减数绝对值-被减数，正数-负数转化为正数+负数的绝对值），这个判定可以在具体使用函数的上下文中单独判定，也可以在API中添加转化。具体逻辑我将在讲解完小数、乘法和除法后给出。

### 3.3 乘法
乘法口诀还记得不？多位数乘法的准则还有印象不。我们需要将被乘数依此与乘数的每一位相乘，记得要补零，然后把这些数依此再加一遍，得出最后的结果。这复杂度是多少？假如乘数是n位，被乘数是m位，第一次逐位相乘最多10m（在乘以n的某一位前，可以判定是否这位数计算过，若计算过直接取结果并补充0，极大的缩减复杂度），补零mn，最后的累加是mn，复杂度大约是(10+2n)n。我们还有另一个方案，阿里系工程师推荐的，乘法的本质是什么，其乘数个被乘数相加，例如5*6，实际上就是5+5+5+5+5+5。这个复杂度是乘数。如果乘数合被乘数有10位，十亿，第一个方案需要循环300次，第二个最少循环10亿次。

这结果太惊悚了，本来我的第一个方案是被阿里系工程师否决掉的，没深入分析过复杂度的问题，当时只是觉得第二个方案可能循环次数会很多，没想到啊，会相差这么多，何况10亿还远远没到达大整数的范围。我先看看JS乘法运算和加法运算之间耗能问题差距大不大，再试着实现一下第一个方案，写出来后再详细对比复杂度和性能问题。



