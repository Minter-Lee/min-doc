#创建一个基本可用的React应用

## 前言
   一个React项目跑起来非常简单，我们仅需要在一个index.html中引用相应的JS文件，就可以在script标签下书写React代码。但放入生产环境下，这种形式是远远不够的，不说PWA应用的构建。我们至少要构建一个SPA应用。构建一个基本可用的应用需要考虑的不仅仅是主干技术（如：React），还需要对项目结构、打包、插件、辅助包、开发规范、业务特性等等内容进行深入研究和取舍。所以这里仅仅讨论一个基本可用的React应用，而不是一个万金油应用。

## 1 技术选型
   首先明确的是，我们构建应用的主要类库是React。之后还有如下技术，需要取舍。
- **平台**： 原来前端项目基本上都是依托于后端项目上，或者就是单纯的前端项目，但这对于React来说是不合适，它与Node平台结合的更好。所以平台必然是Node。

- **包管理**： 在这方面我们基本上是选用Node自带的NPM。当然也可以选用Yarn，不过从项目角度考虑，我们对安装速度的一致性和是否允许安装时执行等问题，不是特别关注。或者说就目前的场景来讲，可以不过多考虑这个问题。

- **打包工具**：打包是现代前端项目非常重要的一个环节，从过去的grunt、gulp到如今的webpack、rollup等。这些工具不仅可以将分散的代码聚拢，合并，压缩。更是可以在打包过程中，进行代码补充、转义、拆分、统一处理等内容，让我们的开发更舒适，更规范，更高效。就目前来讲webpack相对大众一些，插件形式也非常灵活，何况还有非常适合小项目调试使用的webpack-dev-server插件。

- **语法**：本来这是一个唯一选项的答案，奈何ES6的出现，因为ES5与ES6甚至是ES7在语法上天差地别，而且ES6语法上有很多非常好的改善。解决了许多ES5使用时的尴尬和繁琐。所以这里我们至少使用ES2015(ES6第一个版本)的规范。

- **插件**：因为ES6语法，更新的很快，很多现代浏览器对它的支持并不统一，所以我们需要将他转为ES5规范，来兼容所有的浏览器，值得庆幸的是babel在这方面做得非常好，配置简单，支持的很全面，就算我们使用ES7语法，babel也能很好的转义，并保留这所有语法的特性（如箭头函数作用域不上升等）。babel可以让我们放心大胆的徜徉在ES6的新语法规范中。

- **样式**：随着JS的发展，CSS也在进步，为了提高CSS的开发效能，解决命名空间等问题。sass、less等css规范相应给出，这里以less的编程能力最变态。但说实话，如果没有什么特别需要，sass、less的选择还是随心所欲的。我们很难或者很少有精力对CSS的构建写非常复杂的函数。还有一种是CSS Modules。这也是一种css的规范，但是如果使用了其他UI，CSS Modules就无能为力了。如果想有更多了解，可以自行谷歌。Post CSS，我认为更像是一种CSS插件，而不是开发的规范。至于CSS In JS，恕精力有限，确实没有深入研究过。暂时不讨论了。

- **路由**：路由是一个项目的入口，而针对于React来讲，肯定是React-Router了。但我们这里面使用的是react-router 4.x。它与之前版本在设计理念上就已经不一样了。之前版本是写入一个Route文件中，层层嵌套。而4.x更推荐分散的来写。而且路由的使用方式也有很大变化。配置时再详细说明

- **状态管理**：我们都知道依托react的状态流转是非常难用的。很容易state泛滥，而且组件间通信，尤其是跨组件通信都非常不方便。所以出现了flux，reflux，redux和mbox等专门管理状态的辅助包。目前主流的是redux和Mbox。针对状态管理这方面，其实两者的最开始的思路是一个，为了跨组件通信，就像涉及的状态提取到两个组件共同父类。不同的时候Redux将所有状态融为一颗树。成为所有组件的数据来源，从而达到所有组件都能访问完整的state树。而Mbox则更为零散，看起来更像是将setState隐藏起来了，通过对数据精确的监控来高效更新组件。而跨组件通信是通过使用一个父类store来完成的。网上有很多，关于二者的对比和应用场景分析。有兴趣可以看看，这里面我选择redux，以及配套的react-redux， react-redux-router。

- **异步方案**：ES6语法中Promise是最常见的异步解决方案。一般情况下我们想服务器的请求都不在使用ajax而是改为Promise。而浏览器fetch是一个不错的选择，简单方面，返回的也全是Promise对象。既然说是方案，就是一套完整的解决方法，而不是单纯一个技术。我们在redux中加载一个数据，至少要发送三个Action，分别再请求时，请求成功和请求失败。然而dispatch的参数是对象，而不是一个函数，为了能使用函数最为参数，我们才使用了redux-thunk这个中间件来进行处理。

- **效能方案**：react本身是一个高效的组件，但是用不好还是会产生很多不必要的diff过程。为了优化这一部分，我们有了诸多的优化手段，如purerender、immutable.js、无状态组件等等。purerender基本上可以弃用了，因为react已经集成了PureComponent。而immutable非常重，尤其是在转化为Immutable对象和转为JS对象时，效能消耗非常高，所以如果不是数据承载量非常大，不建议使用。划分好组件更直接有效。

从以上的技术选型来看，一个可以在生产环境基本可用的react项目，构建并不简单。接下来是更麻烦的，我们需要开始筹备项目目录，一步步将这些内容安装、串联、调试，再根据业务场景逐步调整架构，使之更健壮。

# 2 项目构建

## 2.1 package.json