# JavaScript继承机制浅析

## 1 面向对象中的继承

### 1.1	继承概述

   继承是面向对象的特征之一。继承是指在一个类基础上定义一个新类，原有的类叫做父类，新生成的类叫子类，继承的过程是一个从一般到特殊的过程。
### 1.2	继承意义

   继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确描述共性的方法，对象的一个新类可以从现有的类中的派出，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。

## 2JavaScript中的继承

### 2.1	概述

   JavaScript是一种脚本语言，是面向过程的语言，但这不代表其不能进行面向对象的编程，JavaScript可以用多种方式实现继承来进行面向对象的编程。JS的继承方式包含多种，主要通过JS中Prototype（原型）完成继承的，故JS又称之为基于原型的语言。Prototype是JS的重要特性，它存储着JS函数中的原型对象，而我们可以通过拓展其原型对象，对函数进行拓展（变量查找机制）。这为继承开启了一扇大门。
   JS中主要可以大致分为基于构造器模式的继承和基于对象模式的继承。从字面上来讲，基本可以看出我们会在JS函数（类似于Java中的类）上动手脚实现继承，以及对实例化后的对象上动手脚实现继承。当然所有的继承模式都不是一蹴而就的，细算开来JS中大约有12种以上的继承方式，但其中一部分是某种成熟继承方法的一部分或者说是中间产物。此处篇幅限制，不在详细的说明每一种，只对相对成熟常用的继承方法进行说明和举例。

### 2.2	基于构造器模式的继承

#### 2.2.1	临时构造器法

   临时构造器法其实是经过3步演化后才形成的成熟继承方法。
   首先，该方法中重要的核心语句：

    Child.prototype = new Parent();

   这也是JS标准中的默认继承方法。通过对子类原型赋值为父类实例化对象，实现子类继承父类。但是我们由于对Child的原型进行了覆盖式的赋值，这会导致Child原型中的constructor指向错误（两个原型赋值先后的对象构造器不同，属性方法也不同），故上述步骤完成后需要追加如下语句，对constructor进行重新定位。

    Child.prototype.constructor = Child;

   在上述的继承方法中新建父类对象是一个费时费力的过程，所以需要优化此处，最简单的方式是将其替代为父类的原型。

    Child.prototype = Parent.prototype;

   使用这种方法，就要求父类在定义时，要将公用需要继承的方法写入prototype中。同时此处也需要将constructor重新定位。这种方法规避了新建父类的损耗，但是不难发现，如果由于此处的引用传递而不是值传递，即父类原型与子类原型指向了同一对象，这导致了子类原型一旦修改父类原型也会同样修改。这种逆向的影响是致命而不可取的。所以才有了临时构造器法，代码如下：
    
    function extend(Child,Parent){
        var F = function(){};
        //构造临时空函数，用于承载Parent的Prototype，规避因引用而导致原型被反向修改
        F.prototype = Parent.prototype;
        //将临时函数实例化后赋值给子类原型
        Child.prototype = new F(); 
        Child.prototype.constructor = Child;
        //增加uber，指向父类Prototype，用于调用父类方法，类似于Java中的super方法
        Child.uber = Parent.prototype;
    }

   这种综合的方法，通过空函数作为中间件，即节约了一部分损耗，又可以规避引用传递所造成的逆向修改的问题。这种成熟的方法被YUI、ExtJS等JS类库使用实现继承。

   如果这时候翻开Backbone的源码你会发现，Backbone也是这种方式。

    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

#### 2.2.2	原型属性拷贝方法

原理很简单，即将父类中原型的内容全部复制给子类原型。代码如下：

    //简单粗暴的复制型继承--复制prototype
    function extendOfCCopy(Child,Parent){
    	var p = Parent.prototype;
    	var c = Child.prototype;
    	for(var i in p){
    		c[i] = p[i]
    	}
    	c.uber = p;
      }

   我形容这种方式是简单粗暴的，很简单很准确的达到了复制的目的，但是这种方式，会导致一个我很爱很爱的问题出现，浅层复制，当迭代p时，简单的将c[i] = p[i]，这种赋值方式是有危险的，对于JS的基本类型来说，c[i]会得到一个全新的副本，而向Array、Object这些非基本对象来说，这种方式仅仅是一个引用，这就意味着如果对Array进行了修正（不是覆盖式的，此处修正指array.push所导致的变化）。那么父类会跟着一起变化。显然这是不成功的继承方法。但确是一个思路，一个由构造器模式过渡到对象模式继承的契机。你可以跳过构造器借用法，直接看基于对象模式的属性拷贝法。

#### 2.2.3	构造器借用法

   这种方法是我见过的第一个没有使用原型实现继承的方法，他还有一个特别雅致的名字：构造器盗用法。这种方法从构造器函数入手，子对象构造器通过call()或者apply()方法调用父对象的构造器。代码如下：

    function Child(){
        Parent.apply(this,arguments);
    }

   构造器借用法有个特别大的优势，由于父对象的属性来自子对象的属性重建的，与原型链模式中子对象属性来自父对象属性重建，正好相反。这就可以从根本上保证了，修改子对象完全不会影响到父对象。因为子对象是完完全全的新值。
   
   相对的有优势就有劣势，当我们还需要从父类的原型中继承属性时，就会出现两次调用父类构造器的问题，场景如下：

    function Child(){
      //第二次调用
      Parent.apply(this,arguments);
    }

    //第一次调用
    Child.prototype = new Parent("1");
    var c = new Child("2");

   这时候c的name属性是2（自身属性），但是其原型链中的name却是1。而且当我们删除了c的name后（delete c.name），再次打印c.name，得到的是1，此时name来自原型链中，已经不是自身属性了，这就证明了Parent的构造器被使用了两次。这是低效而无用的重复操作。那么我们将第一次调用时的代码进行改造，规避新建父类对象所造成的资源浪费。第一次调用的目的是为了继承父类的prototype中的属性。故可以使用原型属性拷贝法或者临时构造器替代。这里我倒是建议后者替代，虽然代码稍稍复杂了一些，但是规避了浅层复制的问题。具体代码如下：

    function Child(){
        Parent.apply(this,arguments);
    }
    //原型属性拷贝
    extendOfCCopy(Child,Parent);
    //或者临时构造器法
    extend (Child,Parent);

### 2.3	基于对象模式的继承
#### 2.3.1	属性拷贝
   属性拷贝分为了2步演化过程，2.2.2节中提到的原型属性拷贝方法，其实已经有了基于对象模式继承的影子，故可以再次演化为全属性拷贝法，代码如下：

    //简单到没朋友的继承方法
    function extendOfCopy(p){
    	var c = {};
    	for(var i in c){
    		c[i] = p[i];
    	}
    	c.uber = p;
    	return c;
    }

   这是Firebug、JQuery早期版本中使用的继承方法。为什么是早期？因为这种方法同原型属性拷贝有着相同的问题，即非基本类型的属性仅是引用复制，会有逆向修改的浅层复制问题。怎样解决？我们不可能不使用非基本类型的属性，但是非基本类型是如何得来的，它是由若干基本类型构造而来的！故我们在复制前判断一下是否是非基本类型，若是非基本类型在循环此方法一遍，直到没有非基本类型为止。代码如下：

    function extendOfDCopy(p,c){
    	var c = c || {}
    	for(var i in p){
    		//过滤出非基本数据类型的属性--注：array和{}都是Object
    		if(typeof p[i] === 'object'){
    		//根据类型不同，给定不同的对象
    			c[i] = (p[i].constructor === 'Array') ? [] : {};
    		//对p[i]中的子属性进行一次复制工作，循环至没有非基本数据类型的属性为止
    			extendOfDCopy(p[i],c[i]);
    		}else{
    		//基本类型属性复制
    			c[i] = p[i];
    		}
    	}
    	return c;
    }

   这种方法即深拷贝法，也是JQuery后期发现浅层复制问题后的修正方法。

#### 2.3.2	原型继承法

   这种方法放弃的仿类的继承模式，而是直接在对象直接构建继承关系，发挥原型的固有优势。代码如下：

    function object(o){
    	//创建一个空函数，用于承载其prototype承载复制进来的原型属性
    	function F(){}
    	//将父对象直接复制过去为子对象的原型
    	F.prototype = o;
    	return new F();
    }

   一般我们使用继承时，主要有两个步骤，第一继承父类，第二扩展父类。我们遵循面向对象的思维，将两个步骤合并为一个方法。那么上述的方式就可以和全属性复制法结合，形成较为完善的继承方法。代码如下：

    function objectPlus(p,stuff){
    	var n;
    	function F(){}
    	F.prototype = p;
    	n = new F();
    	//不在需要担心浅层复制的问题--stuff的级联修正完全不影响
    	for(var i in stuff){
    		n[i] = stuff[i];
    	}
    	return n;
    }

   我们说过，全属性拷贝法是会有浅层复制的问题的，但那是复制的对象是父类，此处的stuff是定义子类时写的扩展方法，不会有逆向影响父类的问题出现。

#### 2.3.3	多重继承及寄生继承

多重继承即可以继承多个父类，其实就是原形继承法的一种迭代扩展，这种继承方法的使用场景是一个类混入其他类时使用。代码如下： 

    function multi(){
    	var n = {} , stuff, j = 0, len = arguments.length;
    		//循环传入的所有参数对象
    	for( j = 0 ; j < len ; j++){
    		stuff = arguments[j];
    		for(var i in stuff){
    			//浅层复制风险
    			n[i] = stuff[i];
    		}
    	}
    	return n;
    }

但是，在学习过程中，我也发现了这种方式存在的隐患。第一，由于是多个父类混入，如果这些父类中出现了相同的属性，那么后者将覆盖前者。第二，由于此处的stuff不仅仅是我们扩展的方法了，还可能是父类，那么全属性拷贝方法会导致浅层复制的问题。
寄生继承是有点狐假虎威的一种继承方法，根据学习中提到的介绍，其主要内容是在创建对象的函数中直接吸收其他对象的功能，然后对其进行扩展并返回的方法。“就好像所有的工作都是自己做的一样”。代码如下：

    var a = {
    	name :"a",
    	code :"01",
    	getName :function(){
    		return this.name;
    	},
    	values :[1,2,3]
    }
    function d (type){
    	var that = object(a);
    	that.name = "d";
    	that.code = "04";
    	that.type = type;
    	that.getType = function(){
    		return this.type;
    	};
    	return that;
    }

我们在a的基础上将d扩展了属性，同时d也继承了a的属性，这就是寄生继承。

### 2.4	总结与鸣谢
首先非常抱歉，这次文档的整理稍显匆忙，从开始到结束大约用了4天晚上的时间，对于JS继承的理解也稍显浅薄，主要是学习了继承的方法和种类，但对于深入的机制和详细的使用场景，目前还不是学习的很透彻。当然这么多继承的方法也绝不是几天就能纯熟应用的，我相信以后的JS开发过程中会更加深入的理解这些方法背后的机制和思路。不过这次学习收获还是非常大的，我详细的整理了以前所了解继承的片段记忆，并通过书中详细的介绍和示例，系统的巩固了一遍。所以首先感谢孔常柱大哥给了我这个学习的机会和动力，我相信没有这个沉甸甸的任务，我想象不到什么时候能够静下心来做这些看似跟实际工作内容无关的事情。同时也非常感谢新胜同学在我最需要系统学习的时候提供了一本JS面向对象编程指南的书（当然他本来是借给昊鹏同学的，被我抢来的）。希望我的这些总结不仅今天对我有意义，也对我及所有阅读的人的明天也有对JS继承的理解能够提供一点儿帮助。
对了，有错别字什么的，先忍忍哈~~

——李磊
2014年11月9日 星期日
