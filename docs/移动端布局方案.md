#移动端布局解决方案

##前言
首先，如果你是来Copy方案的，那抱歉这篇文档没有完整的源码，其次如果你想了解方案思路而不想听作者絮叨心路历程，请跳过下面这段。

在原来的工作中，曾经做过一些移动端的切图工作，在HTML文件头部加入meta标签，书写viewport相关设置，就能开始正常的切图工作了。但是，当时能力有限，从未考虑过这些为什么做这些配置，如果说是为了高度还原设计图的话，我在实际切图过程中发现高度和字体问题就很难解决，不同屏幕下这些字体大小高度大小，都没有得到很好的适配工作，加入viewport唯一看到的结果就是屏幕面积等于可视面积了，width=100%表示屏幕可视区域的宽度，这背后意味着什么并不清楚。后来进入移动组进行开发，在指定开发框架下，也没有去仔细考虑探索它的适配方案，应该说没关心这部分内容，仅仅是按照要求使用rem单位书写CSS。通过rem布局来保证各类屏幕的适配工作，保证大小比例基本一致，同时疑惑为什么根节点的font-size固定为100px，不理解这种掩耳盗铃的布局方式怎样去适配各类大小的屏幕。虽然存疑，却一直没有去想着深入研究，只顾着开发好react相关的代码，这是我一直存在的缺点。时常表面理解这些内容后就不在关心了，或者自己不负责就不敢去质疑。所以报应来了，最近在找工作的过程中，经常被问到移动端适配的方案，模糊的回答需要使用rem布局，并且动态修正font-size，却一直无法说的清楚明白。近几日探索flex布局时，又看到了移动端适配方案的问题，看过几个方案后，决定书写这篇文档来表述一个简单的适配方案。写到initial-scale时发现不知道为啥一定要配置viewport标签，后续content中的内容更是知其然不知其所以然。这几套方案再精妙无法溯本求源的了解原始问题原始需求，很容易被带进坑里而不自知。我们都知道移动端开发要设置viewport，要计算initial-scale比例，要计算根节点的font-size；但是这些设置是解决方法，而问题的出发点却往往被依据保证适配而遮盖。究其缘由，我觉得是大部分人不想知道这些，就想着复制后能解决问题就行，最多知道那些设置什么意思就够了。我不再想这么下去，于是又研究了一些文章，做了一些实践。再次来重新书写这篇文档。

## 1. 一些基本概念
我写着写着发现阐述一个问题时，需要不断补充一些基本概念，还不如写在这里，简单介绍一下。方便理解和逻辑的梳理。

### 1.1. dpr 
   全称DevicePixelRatio，官方定义为设备物理像素与设备独立像素的比例。设备独立像素可以理解为逻辑像素，可以具象化为CSS像素。
   
   在PC端中，我们设定1pxCSS像素，屏幕上就渲染1px物理像素。使得误认为1px就代表着1px真实物理像素。实际上这种等于并不稳定，在移动端中，越来越多的高清屏出现，我们可能忽略了一点，很多高清屏其实和普通屏尺寸相差不大甚至是一致。例如IPhone3GS和IPhone4，它们屏幕尺寸是一样的，但是分别率却相差一倍，这意味着什么？这意味着同样大小的情况下物理像素密度多了1倍，那么，你有发现IPhone4的渲染内容多了1倍吗？当然不会，这些多出的物理像素是为了更清晰的渲染内容，而不是承载更多内容。那这些是靠什么转化和标识的，就是DPR。

   下面是一个dpr=1和dpr=2的两个设备上，渲染物理像素差异的示例：

   ![](https://i.imgur.com/FUUIMrH.jpg)


   至于说同等尺寸下为什么物理像素越多越清晰，可以参看这张图理解，这里就不赘述了：

   ![](https://i.imgur.com/PW1drvg.jpg)


## 2. Viewport

方案的制定不是凭空出现的，一切皆有源头。我们先来理解一个重要的概念——Viewport。它是指移动端屏幕用来显示网页的区域。该区域包含移动端屏幕的可视范围，绝大部分情况下比可视范围要大，它的大小默认是由厂商指定的，一般为980px，IE为1024px。Viewport大小比可视区域大，是为了适配PC端网页在移动端上的浏览。移动端屏幕可视区域相对放大了PC端的网页（显示PC端一部分内容），避免字体过小等问题。

这个Viewport被PPK大神称为Layout Viewport（布局窗口）。为什么要细化这个名称，是因为对于移动端来说还有2个Viewport概念，这三个概念可以帮助我们更清晰的理解移动端诸多适配问题的产生原因和解决方法。

第二个Viewport为Visual Viewport（虚拟窗口），它是指移动端屏幕的可视区域。这个区域的大小就是设备的物理像素点阵。也就是我们常说的分辨率，例如在IPhone5上就是640 * 1136，在IPhone6上就是750 * 1334。

第三个Viewport就是Ideal Viewport（理想窗口），它的产生是dpr带来的，我在dpr介绍中说过，dpr越大并不是为了渲染更多内容，而是为了渲染更清晰的内容。所以在上述两个Viewport之下，我们需要一个与dpr成关系的Viewport，来保证个设备的渲染比例基本一致。所以Ideal Viewport的大小即为分辨率/dpr。如IPhone5的Ideal Viewport大小即为320 * 568（IPhone5 dpr = 2）。

## 3. 第一个问题

介绍了Viewport之后，我们需要回溯一下移动端的问题，那就是设备屏幕大小不一，同时普遍逻辑分辨率小于PC端分辨率。所以我们不会要求移动端上要实现PC端的效果，我们一般都是针对移动端单独切图，单独开发。面对特殊化的移动端设计形式，Layout Viewport默认的宽度显然不符合要求，所以第一个要解决的问题就是要将Layout Viewport 缩小到与Ideal Viewport一致。这里需要注意一点，Ideal Viewprot 表示的实际大小与Visual Viewport的实际大小是一致的，即屏幕尺寸，数值上的不一致是因为DPR的存在，而Layout Viewport的数值单位是CSS像素，所以这里说缩小到与Ideal Viewport一致，这也是Ideal Viewport这个概念存在的重要作用。请充分理解上面的论述，这是对Viewport概念划分后最主要的作用。既然要缩放viewport，需要怎么做呢？HTML提供了meta标签来进行设置。

###  3.1. meta标签

你一定见过下面这段标签文本

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minximun-scale=1">

网上绝大多数的文档中都会告诉我们，加入这段标签，设备就没有横向滚动条了，但是为啥有滚动条？怎么就没了？我想很少有提及。反正加入之后我能用就得了呗。最多我知道device-width是设备宽度，initial-scale是缩放比例。但是设备宽度取得是哪类viewport的宽度，设置后影响点在哪里？initial-scale是谁对比谁的缩放？它与device-width有什么关联？如果你没想这么多，我倒是建议多想想多看看多做做。OK，接下来，我会把这个标签单独设置一遍，针对每个设置项逐项分析作用，看看这背后有什么。

#### 3.1.1. device-width

    <meta name="viewport" content="width=device-width">

   content中的只有一个配置项，将当前Layout Viewport的宽度设定为设备宽度，这个设备宽度就是Ideal Viewport的宽度，例如IPhone5，物理像素宽度为640px，逻辑像素宽度为320px，设定后当前HTML的宽度已经从980px变为320px。等等，就目前的效果看，我们不是已经达到了缩放Layout Viewport为Ideal Viewport的目的了吗，那还要initial-scale做什么？带着这个疑问再来看看initial-scale设定。

#### 3.1.2. initial-scale

    <meta name="viewport" content="initial-scale=1">

   将content中的width设置注释掉，加入initial-scale=1。哦呵呵，它与直接设置width的效果是一致的，为啥呢？前面我提过，initial-scale是谁对谁的比例，其实initial-scale=1代表着将当前viewport不缩放，也就是保持Ideal Viewport。那也就意味着默认情况下这个initial-scale不是1，结论是当然，Layout Viewport默认是被厂商处理过的（如980px）。请注意，详细说明这些就是为了证明，**大道万千又殊途同归**，而这**途**是需要我们去了解的。
    
   既然作用一致，那为何你观察到的方案中，两个配置项都写了呢？有人会说initial-scale还会有其他作用（后续会说），所以我们把width的设置去掉可否？答案是不行！

   其实这是个兼容处理，我盗了一些图，来看看这两配置项的兼容性，

device-width兼容性

![](https://i.imgur.com/x8p8aKb.png)

initial-scale兼容性

![](https://i.imgur.com/5vfAW0T.png)
     
在device-width上有句话，Safari applies the portrait width (320 or 768) to both landspace and portrait modes。即无论是竖屏还是横屏，宽度都是竖屏是的Ideal Viewport的宽度。再看initial-scale，显然IE在此配置下，横竖屏有问题。两个配置都会有一些小问题（虽然很多应用不兼容横屏），那都配置下就可以互补之间的缺点了不是。这就是这两个配置项都使用的原因。

在此maximum-scale和minimum-scale是scale的边界值设定，就不赘述了，一遍兼容方案中三值固定为一个，比较好控制屏幕比例变化。还要一个值是user-scalable，是否允许用户缩放，一遍就是no，这也是出于减少变数增加稳定的原因出发。

好了，如果我们加入meta标签后，我们解决了第一个问题，把屏幕尺寸变为屏幕的逻辑像素尺寸，不仅符合移动端设计要求，更方面我们开发。那么第二个问题就来了！

## 4. 第二问题
我们设定meta标签后，IPhone5下宽度是320px，IPhone6下宽度是375px。其他设备尺寸也都不一致。当我们画一个100px的正方形时，你会发现各类屏幕上显示的比例很不一致。这会导致我们元素的排列出现问题，有人说我们可以使用flex和比例来解决。但是这仅能解决横向的问题，纵向呢，我们元素的高怎么办？宽度可以固化，高度不行，大量的内容需要不断的向下排列，高度是不可控的。更何况这仅仅是元素，还有字体大小的问题。那怎样保证不同dpr，不同分辨率的屏幕，元素看起来大小一致呢？答案是利用各类屏幕的差异动态缩放，而缩放有两方面，initial-scale值、根节点字体（REM布局）和字体。

### 4.1 initial-scale

它的设定是为了还原逻辑像素与物理像素的比例，抹平dpr的影响。公式很简单，initial-scale=1/dpr。我们通过缩小CSS的数值来保证物理像素的高度还原。那为了什么呢？我们可以精确还原border 1px的问题。不需要每次都去转化倍数。当然这也带来了一些问题，需要在rem布局时也通过物理像素来进行设定，补充缩放带来的问题。

### 4.1 REM布局
我们先说说REM布局，REM布局可以说是移动端开发必备的，它的统一缩放特性可以通过修正根节点的font-size来缩放整个页面使用rem单位设定尺寸的大小。也就是计算好font-size就是REM布局的关键。我们应该使用Visual Viewport的宽度来确定font-size的数值。就是：逻辑像素宽度*dpr/10来计算，10视为方便使用添加的常数，不是什么特殊的参数，计算后IPhone5就是64px，IPhone6为75px。

我们可以通过JS来设定也可以通过媒体查询标签来设定，这里就不赘述了，相关代码网上一大片我就不摘抄了。再来说说实际应用过程中一个非常恶心的事情，那就是计算起来特别麻烦。75、64都不是很好整除的数，我曾经看过简单的以dpr=1为基础，根据dpr来倍增font-size，例如dpr=1时font-size为50px，那IPhone5\6根节点都是100px。这里面计算就方便很多了，但是由于忽略了dpr外的因素，所以无法达到精准的还原设计图，所以我还是不太推荐。那我们就提供个计算器呗，具有强大编程能力的less可以针对此设定一个px2rem的方法，公式为：height/基准值，这里的基准值是通过设计图来确定的，就是屏幕的物理像素宽度，IPhone5设计图宽度是640，那基准值就是64。请注意，根节点的font-size是计算得来的，这个基准值仅是它众多子集之一，不要弄混。基准值是根据设计图确定的，是为了设定该屏幕下切图尺寸，为更多屏幕提供基准参数。

less的具体方法如下（我还没用过......）

    // 例如: .px2rem(height, 80);
    .px2rem(@name, @px){
        @{name}: @px / 75 * 1rem;
     }
所以，对于宽高750×300px的div，我们用less就这样写：

    .px2rem(width, 750);
    .px2rem(height, 300);

OK，针对REM布局的方案基本就是如此，完整的源码和方案，等我有货了再补充。

### 4.2 字体

还是font-size，不过这个就是具体的文本的字体大小了，不是REM的基准值了。其实这是为了保证字体上比例一致，我们可以直接使用REM提供的rem单位来进行设定，基本上可以达到正常比例效果。但是rem相对跨度比较大，所以也可以通过类似REM根节点基准值计算的方法来确定文本大小，依旧可以使用less来做处理。

    .px2px(@name, @px){
        @{name}: round(@px / 2) * 1px;
        [data-dpr="2"] & {
            @{name}: @px * 1px;
        }
        // for mx3
        [data-dpr="2.5"] & {
            @{name}: round(@px * 2.5 / 2) * 1px;
        }
        // for 小米note
        [data-dpr="2.75"] & {
            @{name}: round(@px * 2.75 / 2) * 1px;
        }
        [data-dpr="3"] & {
            @{name}: round(@px / 2 * 3) * 1px
        }
        // for 三星note4
        [data-dpr="4"] & {
            @{name}: @px * 2px;
        }
    }

上边这个方法是我抄来的，我没有使用过字体精确控制的方法。但是如果需要保证各类屏幕同字体大小一致，确实需要通过上述方式来计算字体。

## 5.第三个问题

是的，一般情况下通过上述三个要点的设置，我们就可以完成移动端的适配方案了，但是我觉得还不够，方案有了，实际应用呢？我说过适配方案中REM布局还不够，还需要flex和比例布局来补完，别看我们用宽度来确定了许多基准值，但实际开发过程中，宽度一边是用比例来做的，这能极大的保证各屏幕显示一致的问题。但是很多时候我们是一个固定宽度像素和若干不固定宽度像素组合的形式，如下：

![](https://i.imgur.com/0iMDcXP.png)

今日消息的宽度是固定的，消息内容的宽度是自动拉伸的，我们怎么做，margin？padding？float？我想写出来都绝对不够优雅，这时候就是flex布局的天下了，固定今日消息的宽度，而消息内容就是flex为1，CSS如下：

    .msgContainer {
        height: 0.7rem;
        border-top: 0.1px solid #333;
        display: flex;
        color: #0082df;
        font-size: 0.3rem;
    }

    .msgContainer .msgHead {
        border-right: 1px solid #333;
        width: 2rem;
        display: flex;
        justify-content: space-evenly;
        align-items: center;
    }

    .msgContainer .sliderMsg {
        flex: 1;
        line-height: 0.7rem;
        text-indent: 0.2rem;
        word-break: break-all;
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
    }

你可能看到了，msgHead中也有display：flex、justify-content和align-items，这是针对框中图片和文字的布局，分别控制了他们垂直居中和水平平均分布。再也不需要使用那么多零碎的margin、padding、float来确定位置，甚至还会出来错乱的问题。当然flex布局还不仅仅能做在这些，来看下图：

![](https://i.imgur.com/z9xgH4x.png)

这是标准的底部工具栏的效果，这里面有三层flex应用。首先通过flex固定工具栏在底部，第二平均分布五个操作按钮位置，第三个罗列图标和文本的位置，保证水平居中。这里面需要注意一个问题，每个操作按钮的宽度最好通过flex-basis来确定下来，这样比较稳定，尺寸填充不满，很容易出现错乱问题。这是一个建议，不是规范。

## 6. 结语

全文8千余字了，其实还有一些我没有说明白，源码也没有提供，这么多纯文本的内容，主要是为了说清适配方案的缘由，而不是简单的告诉你我用了什么，我觉得说清楚思路后，根据当前工程的格局，动态来组合实现自己的适配方案，才是最好的。单纯抄或许能快速解决一部分问题，但埋下的隐患是无穷的，何况你不了解原理，改都不会改。这是一种态度，一个优秀工程师的态度，是我原来一直欠缺的精神，我后续会删掉一些抄来的文档，研究通透后从本质出发，再来分析。OK，这篇文章写了2遍了，从着重落地到后来着重原理，各有优点，工程化后我会再来这篇文档，将它落地，同时增加更多关于Android和IOS特殊处理的方案。